---
title: "Filtering of chromatographic peaks in an XCMS object"
author: "Kristian PirttilÃ¤"
date: '2021-05-05'
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
vignette: >
  %\VignetteIndexEntry{Filtering of chromatographic peaks in an XCMS object}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignettePackage{cpc}
  %\VignetteDepends{xcms}
  %\VignetteKeywords{mass spectrometry, lcms, metabolomics, xcms}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

This tutorial will describe the CPC package functionality using an example data set composed of 4 replicate injections of protein precipitated plasma on a HILIC platform. The example data is heavily filtered in order to keep package size and processing times to a minimum. The filtering is made in two steps: (1) The full data set was processed using XCMS and CPC in the same way described below. A subset of 100 peaks was randomly selected from those that were retained in the filtering step, based on the calculated signal-to-noise of the peaks (25 from each quartile). Similarily 100 peaks were randomly selected from those removed in the filtering step (33-34 each from those removed due to not being detected, having too low signal to noise, or having too few data points along the peak range). (2) The data set was then filtered to (i) only include scan indices 1-1200, (ii) only include mass peaks with intensity > 2.225*median intensity (removes a lot of noise peaks), and (iii) include only mass peaks whose m/z value coincide with one of the selected peaks in step (1) within a ppm value of 50 and a retention window of +/- 120 seconds.

# Setup environment

```{r setup}

library(xcms)
library(cpc)

```

# XCMS processing

The first step in this tutorial is to use XCMS to process the reduced data set. The parameters used here are the same as those used to process the full data set. For more information on how to use XCMS for processing LC/MS data, see XCMS documentation. Only the peak picking will be performed as the retention alignment will not work properly with this heavily filtered dataset, and is not important to illustrate the workflow.

```{r}

# get example raw data file paths from package
fp_raw <- list.files(system.file("extdata", package = "cpc"), full.names = T)
# fp_raw <- list.files(path = paste0("C:/Users/kripi733/Work Folders/Documents/", 
#                                    "4_R/Projects/cpc/inst/extdata"), 
#                      full.names = T)
# 
# fp_raw <- list.files(path = paste0("C:/Users/kripi733/Work Folders/Documents/", 
#                                    "4_R/Projects/cpc/loc_data/filtered2/"), 
#                      full.names = T, pattern = "*.mzML")

# setup multi-core processing for XCMS
register(bpstart(SnowParam()))

# setup metadata
(pd <- data.frame(sample_name = paste0("HILIC_", seq(1,4,1)),
                  sample_group = rep("HILIC_POS", 4),
                  stringsAsFactors = F))

# Create raw data object
(msraw <- readMSData(files = fp_raw,
                     pdata = new("NAnnotatedDataFrame", pd),
                     mode = "onDisk", msLevel. = 1, centroided. = T))

# --- PEAK DETECTION ---
cat(paste0("Peak picking start at: ", Sys.time(), "\n"))

# run peak detection
xd <- findChromPeaks(msraw, 
                     param = CentWaveParam(ppm = 60, 
                                           peakwidth = c(5, 50), 
                                           fitgauss = T, 
                                           noise = 200,
                                           integrate = 2, 
                                           prefilter = c(5, 1000), 
                                           verboseColumns = T, 
                                           mzdiff = 0.01), 
                     msLevel = 1L)

print(xd)

```

# CPC peak filtering

The way in which the CPC package is applied to the workflow is via two wrapper functions, *characterize_peaklist()* and *filter_xcms_peaklist()*. The first one will only characterize the peaks detected by XCMS and returns a *cpc* object, whereas the second will call *characterize_peaklist()* as well as run the filtering method and can return either a *cpc* object containing all the information, including the filtered XCMSnExp object, or only the filtered XCMSnExp object. For incorporating the package into an XCMS workflow, it is recommended to use the function *filter_xcms_peaklist()* with *return_type = "xcms"* or use the *getFilteredXCMS()* method on the *cpc* object returned by *filter_xcms_peaklist()* as both cases will give the same result. The latter case will be used in this tutorial as we want to keep the information contained in the *cpc* object.

The *cpcProcParam* object holds processing parameters for both peak characterization as well as peak filtering.

```{r}

cpc <- filter_xcms_peaklist(xd = xd, return_type = "cpc", 
                            param = cpcProcParam())

```

With this data set the processing times are very fast (<10 seconds per file), but that is due to the heavy filtering that has been done. More realistic processing times, when working with full LC/MS data sets, range from a 2-10 minutes per file, depending on the number of peaks.

After processing we can get the original peak table from the XCMS object and the characterized peak table from the CPC object using the methods *cpt* and *getPeaklist*.

```{r}

cpcPeaktable <- cpc::cpt(cpc)

```

The peak table that you get from the CPC package has a number of determined peak characteristics as well as calculated peak characteristics.

| Column | Description |
|--------|-------------|
| id | The row number of the peak in the original peak table from XCMS. |
| apex | The most intense scan point in the peak. |
| finf | The interpolated front inflection point of the peak where the second derivative crosses zero. |
| tinf | The interpolated tail inflection point of the peak where the second derivative crosses zero. |
| fblb | The determined front baseline boundary scan. |
| tblb | The determined tail baseline boundary scan. |
| fpkb | The determined front peak bound. |
| tpkb | The determined tail peak bound. |
| fcode | The front peak bound type (B = baseline, V = valley, S = shoulder, R = rounded peak). |
| tcode | The tail peak bound type (B = baseline, V = valley, S = shoulder, R = rounded peak). |
| blslp | The slope of the baseline calculated between fblb and tblb. |
| emu | The mu value of the fitted exponentially modified gaussian (EMG) function. This is only calculated if EMG deconvolution is turned on. |
| esigma | The sigma value of the fitted EMG function. This is only calculated if EMG deconvolution is turned on. |
| elambda | The lambda value of the fitted EMG function. This is only calculated if EMG deconvolution is turned on. |
| earea | The area modifier of the fitted EMG function. This is only calculated if EMG deconvolution is turned on. |
| econv | An indicator if the Nelder-Mead minimizer converged when performing EMG deconvolution. |
| note | A character statement describing the result of the peak processing. This can be "detected", "not_detected", "too_narrow", "low_sn", "too_small". |
| height | The peak height calculated between the apex scan point and the interpolated baseline value at that point. |
| fh1b | Front bound at 1% peak height. |
| th1b | Tail bound at 1% peak height. | 
| fh5b | Front bound at 5% peak height. |
| th5b | Tail bound at 5% peak height. |
| fh50b | Front bound at 50% peak height. |
| th50b | Tail bound at 50% peak height. |
| wb | Base width of the peak calculated as th5b-fh5b. |
| fwhm | Full width at half maxima of the peak calculated as th50b-fh50b. |
| area | The area of the peak calculated using a trapezoid integrator between fh1b and th1b. |
| a | *apex* - *fpkb*. Used to calculate the tailing factor. |
| b | *tpkb* - *apex*. Used to calculate the tailing factor. |
| tf | The tailing factor calculated as *tf* = *b*/*a*. |
| sn | The calculated signal-to-noise ratio calculated as *sn* = 2**height*/noise. |
| file | Which sample file the peak was detected in. |
| exectime | The execution time for the peak in seconds. |

# Visualizing the results

First lets determine which peaks are kept and which are filtered. In the *cpc* object, there are two *XCMSnExp* objects, *xd* and *xdFilt*. *xdFilt*, as the name implies, is the filtered *XCMSnExp* object. It can be extracted using the *filteredObject()* method.

```{r}

# get the original xcms object using getOriginalXCMS()
xdOrig <- cpc::getOriginalXCMS(cpc)

xdOrig

# get the original peak table
xcmsPeaktableOrig <- data.frame(xcms::chromPeaks(xdOrig))

# get the filtered xcms object using getFilteredXCMS()
xdFilt <- cpc::getFilteredXCMS(cpc)

xdFilt

# get the filtered peak table
xcmsPeaktableFilt <- data.frame(xcms::chromPeaks(xdFilt))

# get the filtered cpc peak table
cpcPeaktableFilt <- cpcPeaktable[row.names(xcmsPeaktableFilt), ]

```

In the original XCMS object there were 1110 peaks identified across 4 files. After filtering using our processing, 913 peaks remain.

To see how many peaks were removed in a file-by-file basis you can use the table function on the chromatographic peak table from the xcms object.

```{r}

rbind(Original = table(xcmsPeaktableOrig[, "sample"]),
      Filtered = table(xcmsPeaktableFilt[, "sample"]),
      Difference = table(chromPeaks(xdOrig)[, "sample"]) - 
        table(chromPeaks(xdFilt)[, "sample"]))

```

As mentioned, in the *note* column of the cpc peak table, the outcome of the peak is defined. To see the distribution of outcomes, we can again use the table function.

```{r}

table(cpcPeaktable$note)

```

To get a vector of the removed peaks, the method *getRemovedPeaks()* can be used which returns a character vector containing the peak IDs of the removed peaks. These can be matched to the row names in the peak table returned by *chromPeaks()*.

```{r}

# set a seed for sample()
seed <- 123

# get all removed peaks
removedPeaks <- cpc::getRemovedPeaks(cpc)
removedPeaksId <- match(removedPeaks, row.names(cpc::getPeaklist(cpc)))

# select 2 each from each of the three categories of peaks removed:
# (1) Not detected as a peak
# (2) Too low signal-to-noise
# (3) Too narrow
set.seed(seed); randomRemoved <- c(
  sample(which(cpcPeaktable$note == "not_detected"), 2, FALSE),
  sample(which(cpcPeaktable$note == "too_narrow"), 2, FALSE),
  sample(which(cpcPeaktable$note == "low_sn"), 2, FALSE)
)

```

And then we can plot these peaks using the plotPeaks function...

```{r fig.width = 7, fig.height = 5}

cpc::plotPeaks(cpc, peakIdx = randomRemoved)

```

In the above plots the original XIC trace is plotted as a gray dashed line with the smoothed chromatogram overlaid on top in black. The black dots are the actual scan points. The blue circles represent the front boundar, apex location, and tail boundary, as determined by XCMS. The red box is the peak boundaries determined by CPC with the red dot representing the apex. The red dashed line is the baseline of the peak, as estimated by CPC.

We can also plot some of the retained peaks in the same way. Here we will randomly select one peak from each quartile of the signal-to-noise range.

```{r}

# get a vector of all detected peaks
allDetectedPeaks <- which(cpcPeaktable$note == "detected")

# determine the quartile break points
quarts <- quantile(cpcPeaktable$sn[allDetectedPeaks])
quarts[1] <- 0 # set the first boundary to be 0

# randomly select peaks in each quartile
noPeakFromEachQuartile <- 2

# randomly select the specified number of peaks from each quartile
set.seed(seed); randomDetected <- c(
  sample(allDetectedPeaks[
    cpcPeaktable$sn[allDetectedPeaks] >= quarts[1] & 
      cpcPeaktable$sn[allDetectedPeaks] < quarts[2]
  ], noPeakFromEachQuartile, FALSE), # 0% <= SN < 25%
  sample(allDetectedPeaks[
    cpcPeaktable$sn[allDetectedPeaks] >= quarts[2] & 
      cpcPeaktable$sn[allDetectedPeaks] < quarts[3]
  ], noPeakFromEachQuartile, FALSE), # 25% <= SN < 50%
  sample(allDetectedPeaks[
    cpcPeaktable$sn[allDetectedPeaks] >= quarts[3] & 
      cpcPeaktable$sn[allDetectedPeaks] < quarts[4]
  ], noPeakFromEachQuartile, FALSE), # 50% <= SN < 75%
  sample(allDetectedPeaks[
    cpcPeaktable$sn[allDetectedPeaks] >= quarts[4] & 
      cpcPeaktable$sn[allDetectedPeaks] < quarts[5]
  ], noPeakFromEachQuartile, FALSE)) # 75% <= SN < 100%

```

And then we can plot all these peaks in the same way as with the removed peaks.

```{r fig.width = 7, fig.height = 5}

cpc::plotPeaks(cpc, peakIdx = randomDetected)

```

```{r}

# m/z ~ apex scan number with point size indicating cpc determined peak area
plot(x = cpcPeaktableFilt$apex, y = xcmsPeaktableFilt$mz, pch = 20, col = "#00000000",
     xlab = "Apex scan number", ylab = "m/z")
points(x = cpcPeaktable$apex[allDetectedPeaks],
       y = xcmsPeaktableOrig$mz[allDetectedPeaks], pch = 20, col = "#55BB0075",
       cex = log(cpcPeaktable$area[allDetectedPeaks] / 
         median(cpcPeaktable$area[allDetectedPeaks])))
points(x = cpcPeaktable$apex[removedPeaksId],
       y = xcmsPeaktableOrig$mz[removedPeaksId], pch = 20, col = "#FF440075",
       cex = log(pmax(0, cpcPeaktable$area[removedPeaksId]) / 
         median(pmax(0, cpcPeaktable$area[removedPeaksId]))))

# m/z ~ apex scan number with point size indicating xcms determined intensity
plot(x = cpcPeaktableFilt$apex, y = xcmsPeaktableFilt$mz, pch = 20, col = "#00000000",
     xlab = "Apex scan number", ylab = "m/z")
points(x = cpcPeaktable$apex[allDetectedPeaks],
       y = xcmsPeaktableOrig$mz[allDetectedPeaks], pch = 20, col = "#55BB0075",
       cex = log(xcmsPeaktableOrig$into[allDetectedPeaks] / 
         median(xcmsPeaktableOrig$into[allDetectedPeaks])))
points(x = cpcPeaktable$apex[removedPeaksId],
       y = xcmsPeaktableOrig$mz[removedPeaksId], pch = 20, col = "#FF440075",
       cex = log(pmax(0, xcmsPeaktableOrig$into[removedPeaksId]) / 
         median(pmax(0, xcmsPeaktableOrig$into[removedPeaksId]))))

```

# Session info

```{r}

sessionInfo()

```