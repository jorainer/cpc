% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\encoding{UTF-8}
\name{process_chromatogram}
\alias{process_chromatogram}
\title{Rcpp wrapper that calls the C++ chromatogram processing framework}
\usage{
process_chromatogram(
  d0,
  d2,
  st,
  apex_thresh = 0,
  w = 5L,
  p = -1L,
  liftoff = 0,
  touchdown = 0.5,
  output = 0L,
  fit_emg = 1L,
  fit_only_vip = 1L,
  fit_hess = 0L,
  fit_rel_lim = 0.05,
  pts_per_peak = 30L,
  min_shoulder_pts = 3L,
  min_rounded_pts = 3L,
  reltol = 1e-08,
  abstol = -1e+35,
  alpha = 1,
  gamma = 2.1,
  rho = 0.75,
  sigma = 0.75,
  maxit = 2000L,
  maxeval = 2000L
)
}
\arguments{
\item{d0}{Numeric vector containing the smoothed XIC trace}

\item{d2}{Numeric vector containing the second derivative of smoothed XIC}

\item{st}{Numeric vector containing scan times}

\item{apex_thresh}{Second derivative threshold value.}

\item{w}{Apex detection window. Do not change unless you know what you are doing.}

\item{p}{Apex location of a specific peak. Leave blank if you wish to process the entire chromatogram.}

\item{liftoff}{Slope difference threshold (in percent) for the peak front.}

\item{touchdown}{Slope difference threshold (in percent) for the peak tail.}

\item{output}{\code{integer} value (0 = no output, 1 = verbose output).}

\item{fit_emg}{Indicates if EMG deconvolution should be performed (0 = no EMG deconvolution, 1 = EMG deconvolution will be performed)}

\item{fit_only_vip}{Indicates if EMG deconvolution should be performed on only the selected peak indicated by p (0 = no, 1 = yes)}

\item{fit_hess}{Deprecated.}

\item{fit_rel_lim}{Minimum relative peak height of neighboring peaks to the selected peak that will be deconvoluted.}

\item{pts_per_peak}{Minimum number of points per peak}

\item{min_shoulder_pts}{Minimum number of points between minima and maxima for at least one of the peaks in a shoulder pair}

\item{min_rounded_pts}{Minimum number of points between minima and maxima for at least one of the peaks in a rounded peak pair}

\item{reltol}{Relative tolerance of the Nelder-Mead minimizer for EMG deconvolution}

\item{abstol}{Absolute tolerance of the Nelder-Mead minimizer for EMG deconvolution}

\item{alpha}{Reflection coefficient of the Nelder-Mead minimizer for EMG deconvolution}

\item{gamma}{Expansion coefficient of the Nelder-Mead minimizer for EMG deconvolution}

\item{rho}{Contraction coefficient of the Nelder-Mead minimizer for EMG deconvolution}

\item{sigma}{Shrink coefficient of the Nelder-Mead minimizer for EMG deconvolution}

\item{maxit}{Maximum iterations for the Nelder-Mead minimizer for EMG deconvolution}

\item{maxeval}{Maximum objective function calls for the Nelder-Mead minimizer for EMG deconvolution}
}
\value{
A list of peak characteristics.
}
\description{
The function takes smoothed d0, d1, and d2 vectors and processes the 
chromatogram by baseline expansion of peaks detected in the second 
derivative. In short, the algorithm detects all peak apices in the 
chromatogram as negative minima craddled by inflection points in the 
second derivative of the chromatogram. Each peak apex detected is then
subjected to a baseline expansion algorithm in order to determine the
peak boundaries and baseline boundaries of the peaks.

It is not recommended to use this function directly unless you know what
you are doing. Instead, use the supplied API functions defined.
}
\examples{
require("signal")
x <- seq(1, 200, 1)
st <- seq_len(length(x))*0.05
vec <- 1e5*dnorm(x, 100, 5) # create a vector with a gaussian peak
noise <- rnorm(length(x), 0, 5) # generate a noise vector
nvec <- vec + noise # create a noisy `chromatogram`.
smvec <- signal::sgolayfilt(nvec, n = 5) # smooth the vector using Savitzky-Golay
ddsmvec <- signal::sgolayfilt(nvec, n = 5, m = 2) # get the second derivative of the smoothed vector
cpc::process_chromatogram(d0 = smvec, d2 = ddsmvec, st = st, apex_thresh = 10)
}
