# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

LinearSpacedArray <- function(a, b, N) {
    .Call(`_cpc_LinearSpacedArray`, a, b, N)
}

c_emgfun <- function(x, pars, npeaks) {
    .Call(`_cpc_c_emgfun`, x, pars, npeaks)
}

testApexFinder <- function(v, w) {
    .Call(`_cpc_testApexFinder`, v, w)
}

#' @encoding UTF-8
#' @title Rcpp wrapper that calls the C++ chromatogram processing framework
#' 
#' @description
#' 
#' The function takes smoothed d0, d1, and d2 vectors and processes the chromatogram by baseline expansion of peaks detected in the second derivative.
#' 
#' Do not use this function, this function is called via the R interface functions.
#'
#' @param d0 Smoothed XIC trace
#' @param d2 Second derivative of smoothed XIC
#' @param apex_thresh Second derivative threshold value.
#' @param w Apex detection window. Do not change unless you know what you are doing.
#' @param p Apex location of a specific peak. Leave blank if you wish to process the entire chromatogram.
#' @param liftoff Slope difference threshold (in percent) for the peak front.
#' @param touchdown Slope difference threshold (in percent) for the peak tail.
#' @param output \code{integer} value (0 = no output, 1 = verbose output).
#' @param fit_emg Indicates if EMG deconvolution should be performed (0 = no EMG deconvolution, 1 = EMG deconvolution will be performed)
#' @param fit_only_vip Indicates if EMG deconvolution should be performed on only the selected peak indicated by p (0 = no, 1 = yes)
#' @param fit_hess Deprecated.
#' @param fit_rel_lim Minimum relative peak height of neighboring peaks to the selected peak that will be deconvoluted.
#' @param pts_per_peak Minimum number of points per peak
#' @param reltol Relative tolerance of the Nelder-Mead minimizer for EMG deconvolution
#' @param abstol Absolute tolerance of the Nelder-Mead minimizer for EMG deconvolution
#' @param alpha Reflection coefficient of the Nelder-Mead minimizer for EMG deconvolution
#' @param gamma Expansion coefficient of the Nelder-Mead minimizer for EMG deconvolution
#' @param rho Contraction coefficient of the Nelder-Mead minimizer for EMG deconvolution
#' @param sigma Shrink coefficient of the Nelder-Mead minimizer for EMG deconvolution
#' @param maxit Maximum iterations for the Nelder-Mead minimizer for EMG deconvolution
#' @param maxeval Maximum objective function calls for the Nelder-Mead minimizer for EMG deconvolution
#' 
#' @return A list of peak characteristics.
#'
#' @export
#'
#' @examples
#' require("signal")
#' x <- seq(1, 200, 1)
#' vec <- 1e5*dnorm(x, 100, 5) # create a vector with a gaussian peak
#' noise <- rnorm(length(x), 0, 5) # generate a noise vector
#' nvec <- vec + noise # create a noisy `chromatogram`.
#' smvec <- signal::sgolayfilt(nvec, n = 5) # smooth the vector using Savitzky-Golay
#' ddsmvec <- signal::sgolayfilt(nvec, n = 5, m = 2) # get the second derivative of the smoothed vector
#' cpc::process_chromatogram(d0 = smvec, d2 = ddsmvec, apex_thresh = 10)
process_chromatogram <- function(d0, d2, apex_thresh = 0.0, w = 5L, p = -1L, liftoff = 0.0, touchdown = 0.5, output = 0L, fit_emg = 1L, fit_only_vip = 1L, fit_hess = 0L, fit_rel_lim = 0.05, pts_per_peak = 10L, reltol = 1.0e-8, abstol = -1.0e35, alpha = 1.0, gamma = 2.1, rho = 0.75, sigma = 0.75, maxit = 2000L, maxeval = 2000L) {
    .Call(`_cpc_process_chromatogram`, d0, d2, apex_thresh, w, p, liftoff, touchdown, output, fit_emg, fit_only_vip, fit_hess, fit_rel_lim, pts_per_peak, reltol, abstol, alpha, gamma, rho, sigma, maxit, maxeval)
}

test_emgfit <- function(x_, y_, wt_, seed_, lower_, upper_, stepsize_, npeaks_, alpha_ = 1.0, gamma_ = 2.0, rho_ = 0.5, sigma_ = 0.5, trace_ = 0L, maxit_ = 500L, maxeval_ = 500L, reltol_ = 1.0e-8, abstol_ = -1.0e-35, trace2_ = 0L, nmin_ = 1L, restart_ = 0L, keep_ = 0L, scalemethod_ = 1L, lambdascale_ = 1.0) {
    .Call(`_cpc_test_emgfit`, x_, y_, wt_, seed_, lower_, upper_, stepsize_, npeaks_, alpha_, gamma_, rho_, sigma_, trace_, maxit_, maxeval_, reltol_, abstol_, trace2_, nmin_, restart_, keep_, scalemethod_, lambdascale_)
}

getEIC_min <- function(mz, intensity, scan_idx, mz_range, scan_range) {
    .Call(`_cpc_getEIC_min`, mz, intensity, scan_idx, mz_range, scan_range)
}

getEIC_Rcpp <- function(mz, intensity, scan_idx, mz_range, scan_range) {
    .Call(`_cpc_getEIC_Rcpp`, mz, intensity, scan_idx, mz_range, scan_range)
}

fast_match <- function(v1, v2) {
    .Call(`_cpc_fast_match`, v1, v2)
}

match_to_range <- function(v, vmin, vmax) {
    .Call(`_cpc_match_to_range`, v, vmin, vmax)
}

skim_to_val <- function(v, val, start_at, break_at, direction = 1L) {
    .Call(`_cpc_skim_to_val`, v, val, start_at, break_at, direction)
}

c_integrate_vector <- function(x, y, a, b) {
    .Call(`_cpc_c_integrate_vector`, x, y, a, b)
}

c_run_mean <- function(x, b) {
    .Call(`_cpc_c_run_mean`, x, b)
}

c_lm_fit <- function(x, y, a = -1L, b = -1L) {
    .Call(`_cpc_c_lm_fit`, x, y, a, b)
}

c_lm_slope <- function(x, y, a = -1L, b = -1L) {
    .Call(`_cpc_c_lm_slope`, x, y, a, b)
}

vector_residual <- function(x, y) {
    .Call(`_cpc_vector_residual`, x, y)
}

c_local_extremes2 <- function(v, w = 2L) {
    .Call(`_cpc_c_local_extremes2`, v, w)
}

c_local_extremes <- function(v, w = 3L) {
    .Call(`_cpc_c_local_extremes`, v, w)
}

c_peak_to_peak_noise <- function(x, y, w) {
    .Call(`_cpc_c_peak_to_peak_noise`, x, y, w)
}

c_running_slope <- function(x, y, w) {
    .Call(`_cpc_c_running_slope`, x, y, w)
}

c_local_max <- function(v, w = 2L) {
    .Call(`_cpc_c_local_max`, v, w)
}

c_local_min <- function(v, w = 2L) {
    .Call(`_cpc_c_local_min`, v, w)
}

c_get_inflection_points <- function(x, b = 0L) {
    .Call(`_cpc_c_get_inflection_points`, x, b)
}

c_get_directional_inflection_points <- function(x, b = 0L) {
    .Call(`_cpc_c_get_directional_inflection_points`, x, b)
}

